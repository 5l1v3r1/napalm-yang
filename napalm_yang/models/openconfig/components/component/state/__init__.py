
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

from . import temperature
from . import memory
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each component
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__id','__description','__mfg_name','__hardware_version','__firmware_version','__software_version','__serial_no','__part_no','__oper_status','__temperature','__memory','__allocated_power','__used_power','__entity_id','__equipment_failure','__equipment_mismatch',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__entity_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/extension', defining_module='openconfig-platform-ext', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__software_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__part_no = YANGDynClass(base=unicode, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__equipment_mismatch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)
    self.__equipment_failure = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)
    self.__serial_no = YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__hardware_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__mfg_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)
    self.__temperature = YANGDynClass(base=temperature.temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    self.__firmware_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-platform-types:TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},),RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/state/name (string)

    YANG Description: Device name for the component -- this will not be a
configurable parameter on many implementations
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Device name for the component -- this will not be a
configurable parameter on many implementations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /components/component/state/type (union)

    YANG Description: Type of component as identified by the system
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /components/component/state/type (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of component as identified by the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-platform-types:TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},),RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-platform-types:TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},),RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-platform-types:TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'CHASSIS': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FRU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'FABRIC': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'LINECARD': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'SENSOR': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'POWER_SUPPLY': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},),RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /components/component/state/id (string)

    YANG Description: Unique identifier assigned by the system for the
component
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /components/component/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier assigned by the system for the
component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/state/description (string)

    YANG Description: System-supplied description of the component
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: System-supplied description of the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_mfg_name(self):
    """
    Getter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    return self.__mfg_name
      
  def _set_mfg_name(self, v, load=False):
    """
    Setter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_name() directly.

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__mfg_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_name(self):
    self.__mfg_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_hardware_version(self):
    """
    Getter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    return self.__hardware_version
      
  def _set_hardware_version(self, v, load=False):
    """
    Setter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_version() directly.

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__hardware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_version(self):
    self.__hardware_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_firmware_version(self):
    """
    Getter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    return self.__firmware_version
      
  def _set_firmware_version(self, v, load=False):
    """
    Setter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware_version() directly.

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__firmware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware_version(self):
    self.__firmware_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /components/component/state/software_version (string)

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /components/component/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=unicode, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_serial_no(self):
    """
    Getter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)

    YANG Description: System-assigned serial number of the component.
    """
    return self.__serial_no
      
  def _set_serial_no(self, v, load=False):
    """
    Setter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial_no() directly.

    YANG Description: System-assigned serial number of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__serial_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial_no(self):
    self.__serial_no = YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_part_no(self):
    """
    Getter method for part_no, mapped from YANG variable /components/component/state/part_no (string)

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replacable unit)
    """
    return self.__part_no
      
  def _set_part_no(self, v, load=False):
    """
    Setter method for part_no, mapped from YANG variable /components/component/state/part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_part_no() directly.

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replacable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_part_no(self):
    self.__part_no = YANGDynClass(base=unicode, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'DISABLED': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {'@namespace': u'http://openconfig.net/yang/platform-types', '@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)


  def _get_temperature(self):
    """
    Getter method for temperature, mapped from YANG variable /components/component/state/temperature (container)

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__temperature
      
  def _set_temperature(self, v, load=False):
    """
    Setter method for temperature, mapped from YANG variable /components/component/state/temperature (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temperature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temperature() directly.

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=temperature.temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temperature must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=temperature.temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)""",
        })

    self.__temperature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temperature(self):
    self.__temperature = YANGDynClass(base=temperature.temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /components/component/state/memory (container)

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /components/component/state/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)


  def _get_allocated_power(self):
    """
    Getter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)

    YANG Description: Power allocated by the system for the component.
    """
    return self.__allocated_power
      
  def _set_allocated_power(self, v, load=False):
    """
    Setter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocated_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocated_power() directly.

    YANG Description: Power allocated by the system for the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocated_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)""",
        })

    self.__allocated_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocated_power(self):
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)


  def _get_used_power(self):
    """
    Getter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)

    YANG Description: Actual power used by the component.
    """
    return self.__used_power
      
  def _set_used_power(self, v, load=False):
    """
    Setter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_used_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_used_power() directly.

    YANG Description: Actual power used by the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """used_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)""",
        })

    self.__used_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_used_power(self):
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)


  def _get_entity_id(self):
    """
    Getter method for entity_id, mapped from YANG variable /components/component/state/entity_id (uint32)

    YANG Description: A unique numeric identifier assigned by the system to the
component. This identifier may be used to represent the
corresponding SNMP Entity MIB identifier.
    """
    return self.__entity_id
      
  def _set_entity_id(self, v, load=False):
    """
    Setter method for entity_id, mapped from YANG variable /components/component/state/entity_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entity_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entity_id() directly.

    YANG Description: A unique numeric identifier assigned by the system to the
component. This identifier may be used to represent the
corresponding SNMP Entity MIB identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/extension', defining_module='openconfig-platform-ext', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entity_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/extension', defining_module='openconfig-platform-ext', yang_type='uint32', is_config=False)""",
        })

    self.__entity_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entity_id(self):
    self.__entity_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="entity-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/extension', defining_module='openconfig-platform-ext', yang_type='uint32', is_config=False)


  def _get_equipment_failure(self):
    """
    Getter method for equipment_failure, mapped from YANG variable /components/component/state/equipment_failure (boolean)

    YANG Description: If true, the hardware indicates that the component's physical equipment
has failed
    """
    return self.__equipment_failure
      
  def _set_equipment_failure(self, v, load=False):
    """
    Setter method for equipment_failure, mapped from YANG variable /components/component/state/equipment_failure (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equipment_failure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equipment_failure() directly.

    YANG Description: If true, the hardware indicates that the component's physical equipment
has failed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equipment_failure must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)""",
        })

    self.__equipment_failure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equipment_failure(self):
    self.__equipment_failure = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)


  def _get_equipment_mismatch(self):
    """
    Getter method for equipment_mismatch, mapped from YANG variable /components/component/state/equipment_mismatch (boolean)

    YANG Description: If true, the hardware indicates that the component inserted into the
affected component's physical location is of a different type than what
is configured
    """
    return self.__equipment_mismatch
      
  def _set_equipment_mismatch(self, v, load=False):
    """
    Setter method for equipment_mismatch, mapped from YANG variable /components/component/state/equipment_mismatch (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equipment_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equipment_mismatch() directly.

    YANG Description: If true, the hardware indicates that the component inserted into the
affected component's physical location is of a different type than what
is configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equipment_mismatch must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)""",
        })

    self.__equipment_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equipment_mismatch(self):
    self.__equipment_mismatch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="equipment-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/alarms', defining_module='openconfig-alarms', yang_type='boolean', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  id = __builtin__.property(_get_id)
  description = __builtin__.property(_get_description)
  mfg_name = __builtin__.property(_get_mfg_name)
  hardware_version = __builtin__.property(_get_hardware_version)
  firmware_version = __builtin__.property(_get_firmware_version)
  software_version = __builtin__.property(_get_software_version)
  serial_no = __builtin__.property(_get_serial_no)
  part_no = __builtin__.property(_get_part_no)
  oper_status = __builtin__.property(_get_oper_status)
  temperature = __builtin__.property(_get_temperature)
  memory = __builtin__.property(_get_memory)
  allocated_power = __builtin__.property(_get_allocated_power)
  used_power = __builtin__.property(_get_used_power)
  entity_id = __builtin__.property(_get_entity_id)
  equipment_failure = __builtin__.property(_get_equipment_failure)
  equipment_mismatch = __builtin__.property(_get_equipment_mismatch)


  _pyangbind_elements = {'name': name, 'type': type, 'id': id, 'description': description, 'mfg_name': mfg_name, 'hardware_version': hardware_version, 'firmware_version': firmware_version, 'software_version': software_version, 'serial_no': serial_no, 'part_no': part_no, 'oper_status': oper_status, 'temperature': temperature, 'memory': memory, 'allocated_power': allocated_power, 'used_power': used_power, 'entity_id': entity_id, 'equipment_failure': equipment_failure, 'equipment_mismatch': equipment_mismatch, }


